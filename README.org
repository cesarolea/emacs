#+TITLE: cesarolea's Emacs Configuration
#+AUTHOR: CÃ©sar Olea

* Preface
This is my Emacs configuration file. It's my first attempt at using
literate programming for configuration, after several (unsuccessful)
attempts at better organization, and going through many Emacs
configuration bankruptcies.

** In the beginning
First and foremost we need to turn off the mouse interface to avoid
momentary display. Also some performance tuning.

#+begin_src emacs-lisp
(dolist (mode
         '(tool-bar-mode                ; No toolbars, more room for text.
           scroll-bar-mode              ; No scroll bars either.
           tool-bar-mode
           menu-bar-mode))
  (funcall mode 0))
#+end_src

Then a ton of configuration variables I've accumulated over the
years. Some I know what they do and are documented. Some I don't have
an idea...

#+begin_src emacs-lisp
  (setq create-lockfiles nil                    ; disable the creation of lockfiles
        auto-save-default nil                   ; don't create autosave files
        load-prefer-newer t                     ; always load newest bytecode
        initial-major-mode 'fundamental-mode    ; prevent loading text mode at startup
        initial-scratch-message (concat "# Welcome " (user-login-name) "!\n# Happy Hacking...\n\n") ; welcome
        mac-command-modifier 'super             ; OSX keybindings
        ns-function-modifier 'hyper
        mac-option-key-is-meta t
        mac-right-option-modifier nil
        custom-file (concat user-emacs-directory "lisp/custom.el") ; avoid adding to init.el
        inhibit-startup-message t               ; don't display startup message
        ns-use-srgb-colorspace t                ; use srgb
        gnutls-algorithm-priority "NORMAL:-VERS-TLS1.3" ; elpa.gnu.org uses TLS1.2, not TLS1.3
        package-archives '(("org"          . "https://orgmode.org/elpa/")
                           ("gnu"          . "https://elpa.gnu.org/packages/")
                           ("melpa-stable" . "https://stable.melpa.org/packages/")
                           ("melpa"        . "https://melpa.org/packages/"))
        exec-path (append exec-path '("/usr/local/bin"))
        confirm-kill-processes nil              ; don't prompt for killing processes
        ns-use-proxy-icon nil                   ; don't display icons in the titlebar
        recenter-positions '(top middle bottom) ; so recentering goes to top, middle and bottom of the frame, in that order
        next-line-add-newlines t                ; add newlines at the end of line with C-n
        ns-pop-up-frames nil                    ; force new frames into existing window
        ring-bell-function 'ignore              ; no bell
        standard-indent 2
        next-line-add-newlines nil              ; no newlines past EOF
        confirm-nonexistent-file-or-buffer nil  ; no confirm opening non-existant files/buffers
        large-file-warning-threshold 100000000  ; warn on opening files bigger than 100MB
        ido-create-new-buffer 'always           ; no prompt for new buffer creation in ido
        kill-buffer-query-functions (remq 'process-kill-buffer-query-function
            kill-buffer-query-functions)
        doc-view-continuous t                   ; scroll PDFs with the mouse wheel
        doc-view-resolution 300                 ; so PDFs don't hurt my eyes
        suggest-key-bindings nil                ; stop telling me the menu command key
        display-line-numbers-grow-only t        ; avoid growing the line number fringe (ie. when going from 99 to 100) causing buffer content shift to the right
        display-line-numbers-type "relative"    ; don't count continuation lines in line numbering
        whitespace-line-column 100              ; limit line length
        whitespace-style '(face tabs empty trailing tab-mark)
        whitespace-display-mappings '((trailing-mark 32 [183] [46])
                                      (newline-mark 10 [182 10])
                                      (tab-mark 9 [9655 9] [92 9]))
        default-major-mode 'text-mode
        x-select-enable-clipboard t
        x-select-enable-primary t
        save-interprogram-paste-before-kill t
        apropos-do-all t
        mouse-yank-at-point t
        dired-listing-switches "-alh"
        search-default-mode #'char-fold-to-regexp
        gc-cons-threshold 100000000
        read-process-output-max (* 1024 1024)
        jit-lock-defer-time nil
        jit-lock-stealth-nice 0.1
        jit-lock-stealth-time 0.2
        jit-lock-stealth-verbose nil
        auto-window-vscroll nil
        scroll-margin 10
        scroll-conservatively 100000
        scroll-preserve-screen-position 1
        frame-title-format '((:eval (if (buffer-file-name)
                                        (abbreviate-file-name (buffer-file-name))
                                      "%b")))
        require-final-newline nil
        dired-recursive-deletes 'always
        dired-recursive-copies 'always
        dired-dwim-target t
        )

  ; themes
  (add-to-list 'custom-theme-load-path (concat user-emacs-directory "themes"))

  ; default spell
  (setq-default ispell-program-name "aspell")

  ; custom font size depending on resolution
  ; doesn't work for emacs daemon instances
  (defun fontify-frame (frame)
    (interactive)
    (set-frame-parameter frame 'font "IBM Plex Mono 14"))

  ; Fontify any future frames
  (push 'fontify-frame after-make-frame-functions)

  ; execution path so homebrew binaries work
  (setenv "PATH" (concat (getenv "PATH") ":/usr/local/bin"))

  ; fontify current frame
  (fontify-frame nil)

  (put 'list-threads 'disabled nil)

  ;; Remove topbar in mac
  (add-to-list 'default-frame-alist '(ns-transparent-titlebar . t))
  (add-to-list 'default-frame-alist '(ns-appearance . dark))
#+end_src


** Backups
   By default, Emacs will create backup files (files ending in ~~~) in
   the same directory as your regular files. This can be a lifesaver,
   but annoying. We can take them out of the way to their own
   directory:

#+begin_src emacs-lisp
(setq version-control t     ;; Use version numbers for backups.
      kept-new-versions 10  ;; Number of newest versions to keep.
      kept-old-versions 0   ;; Number of oldest versions to keep.
      delete-old-versions t ;; Don't ask to delete excess backup versions.
      backup-by-copying t)  ;; Copy all files, don't rename them.

;; Default and per-save backups go here:
(setq backup-directory-alist '(("" . "~/.config/emacs/backups")))
#+end_src

* Packages
I use [[https://github.com/jwiegley/use-package][use-package]] for isolating package configuration. By default all
packages are installed from [[https://stable.melpa.org/#/][MELPA Stable]], and individual packages may
be pinned to regular MELPA if they are not found in the stable repo,
or if a newer version is desired.

** Basic Configuration
~use-package~ can also install selected packages by using the
~:ensure~ key. By having this setting set to ~true~ for all packages,
we can clone this configuration from the repository and, at first
load, it will fetch all packages and install them.

In order to use ~use-package~, we must first install it.

#+begin_src emacs-lisp
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))
(eval-when-compile
  (require 'use-package))

(require 'package)

;; Default to using melpa-stable, unless we override at the package level.
(setq use-package-always-pin "melpa-stable"
      use-package-always-ensure t)
#+end_src

*** Diminish
 This is an add-on to ~use-package~ to be able to specify directly in
 the package declaration, that we want to diminish that mode.

 #+begin_src emacs-lisp
 (use-package diminish)

 (eval-after-load "visual-line" '(diminish 'visual-line-mode))
 (eval-after-load "abbrev" '(diminish 'abbrev-mode))
 (eval-after-load "eldoc" '(diminish 'eldoc-mode))
 (eval-after-load "autorevert" '(diminish 'auto-revert-mode))
 #+end_src

*** Which key
Which key makes it easier to discover the major mode you are in.

#+begin_src emacs-lisp
(use-package which-key
  :bind ("s-W" . which-key-show-major-mode)
  :diminish
  :config (which-key-mode)
          (which-key-setup-side-window-right-bottom)
          (setq which-key-idle-delay 2))
#+end_src

*** Ensure system package
 This package allows you to install related binary (or system) programs
 are installed when certain packages are installed.

 #+begin_src emacs-lisp
 (use-package use-package-ensure-system-package)
 #+end_src

*** Theme
 I use the Doom theme with the Doom modeline. This requires icon
 configuration. The modeline configuration has a fix so that icons are
 shown in the modeline when connecting to an Emacs daemon instance with ~emacsclient~.

 #+begin_src emacs-lisp
 (use-package all-the-icons)

 (use-package doom-themes
  :config
  (setq doom-themes-enable-bold t
        doom-themes-enable-italic t)
  (load-theme 'doom-one t)
  (doom-themes-neotree-config)
  (doom-themes-org-config)
  (global-hl-line-mode 1))

 (use-package doom-modeline
   :init (doom-modeline-mode 1)
   :config
   ;; so that modeline icons work in emacsclient
   (defun enable-doom-modeline-icons (_frame)
     (setq doom-modeline-icon t))

   (add-hook 'after-make-frame-functions
             #'enable-doom-modeline-icons)

   (setq doom-modeline-buffer-encoding t
         doom-modeline-modal-icon t
         doom-modeline-env-version t
         inhibit-compacting-font-caches t))
 #+end_src

*** Exec path
 This package ensures that your Emacs instance is able to use the same
 environment variables as your shell. Especially useful if you use
 non-standard shells such as the fish shell.

 #+begin_src emacs-lisp
 (use-package exec-path-from-shell
   :config
   (when (memq window-system '(mac ns x))
     (exec-path-from-shell-initialize)))
 #+end_src

*** Popwin mode
 Popwin is a popup window manager for Emacs which makes you free from
 the hell of annoying buffers that popup all over the place.

 #+begin_src emacs-lisp
 (use-package popwin :config (popwin-mode 1))
 #+end_src

*** Window movement
 Use shift + arrow keys to switch between visible buffers. Also
 ~ace-window~ for quickly jumping back and forth between windows.

 #+begin_src emacs-lisp
 (use-package windmove
   :config (windmove-default-keybindings))

 (use-package ace-window
   :init (progn
           (define-key global-map (kbd "M-'") 'ace-window)
           (define-key global-map (kbd "C-M-'") 'aw-flip-window)
           (define-key global-map (kbd "C-x o") nil)))
 #+end_src

*** Smooth scrolling
 What says in the label.

 #+begin_src emacs-lisp
 (use-package smooth-scroll
   :config (progn
             (smooth-scroll-mode 1)
             (setq smooth-scroll-margin 5))
   :diminish smooth-scroll-mode)
 #+end_src
** Flycheck
On the fly linter and syntax checker. I want this enabled in all
programming modes.

#+begin_src emacs-lisp
(use-package flycheck :pin melpa
  :hook ((prog-mode . flycheck-mode)
         (org-mode  . flycheck-mode))
  :diminish flycheck-mode)
#+end_src

*** Additional checkers
Add Flycheck support for both Rust and Clojure.

#+begin_src emacs-lisp
(use-package flycheck-clj-kondo)

(use-package flycheck-rust
  :config
  (add-hook 'flycheck-mode-hook #'flycheck-rust-setup)
  (setenv "PATH" (concat (getenv "PATH") ":~/.cargo/bin"))
  (setq exec-path (append exec-path '("~/.cargo/bin"))))
#+end_src

** Magit
The mighty Magit. Some consider this to be the killer application for
Emacs. Don't use git without it.

I have it bound to ~<f10>~. Also:

- ~magit-last-seen-setup-instructions~ is so that magit doesn't prompt
  you to see setup instructions on first load.
- ~magit-push-always-verify~ is related to an option added at some
  point that allows you to make magit confirm certain push
  operations. Setting it to ~nil~ makes push commands behave as
  expected.
- ~magit-branch-read-upstream-first~ When creating a branch, whether
  to read the upstream branch before the name of the branch that is to
  be created.
- ~global-magit-file-mode~ Enable certain magit actions in files that
  are part of a git repository.

#+begin_src emacs-lisp
(use-package magit
  :bind ("<f10>" . magit-status)
  :config
  (setq magit-last-seen-setup-instructions "1.4"
        magit-push-always-verify nil
        magit-branch-read-upstream-first nil
        global-magit-file-mode 1)
  (if (bound-and-true-p magit-auto-revert-mode)
      (diminish 'magit-auto-revert-mode))
  :diminish magit-mode)
#+end_src

** savehist
Savehist mode saves some of your session history in between
restart. Since I use Emacs as a daemon this is not as needed now, but
still nice when using standalone Emacs sessions.

It is configured to save search ring entries, and to keep the saved
history in a ~savehist~ file inside the configuration directory.

#+begin_src emacs-lisp
(use-package savehist
  :config
  (setq savehist-additional-variables
        ;; search entries
        '(search-ring regexp-search-ring)
        ;; save every minute
        savehist-autosave-interval 60
        ;; keep the home clean
        savehist-file (expand-file-name "savehist"
(expand-file-name "savefile" user-emacs-directory)))
  (savehist-mode 1))
#+end_src

** Rainbow mode
So that typing the name of a color or its hex value, displays the
actual color.

#+begin_src emacs-lisp
(use-package rainbow-mode :diminish rainbow-mode :pin gnu)
#+end_src

** Recentf
Keeps track of your most recent opened files so you can get back to
them easily. You can specify files to ignore, which is useful for
files that get visited automatically and fill up your recent file history.

#+begin_src emacs-lisp
  (use-package recentf
    :hook (after-init . recentf-mode)
    :bind ("\C-x\ \C-r" . recentf-open-files)
    :config
    (recentf-mode 1)
    (add-to-list 'recentf-exclude (format "%s/\\.config/emacs/elpa/.*" (getenv "HOME")))
    (add-to-list 'recentf-exclude (format "%s/\\.config/emacs/ido.last" (getenv "HOME")))
    (add-to-list 'recentf-exclude (format "%s/\\.config/emacs/bookmarks" (getenv "HOME")))
    (add-to-list 'recentf-exclude (format "%s/\\.config/emacs/recentf" (getenv "HOME")))
    (add-to-list 'recentf-exclude (format "%s/Sync/Org/roam/.*" (getenv "HOME")))
    (setq recentf-max-menu-items 25
          recentf-max-saved-items 20000000))
#+end_src

** Completion engine
Company is a completion engine for Emacs. You can install several
backends. Useful in programming modes. I'm installing the lsp backend
for using company completion in languages that use LSP (such as rust).

#+begin_src emacs-lisp
  (use-package company
    :hook ((cider-repl-mode . company-mode)
           (cider-mode      . company-mode)
           (clojure-mode    . company-mode))
    :bind (:map company-active-map
                ("C-n" .   company-select-next)
                ("C-p" .   company-select-previous)
                ("RET" .   company-complete-selection)
                ("<ret>" . company-complete-selection))
    :config
    (setq company-tooltip-align-annotations t
          company-minimum-prefix-length 1
          company-idle-delay 0.0)
    (global-set-key (kbd "C-'") 'company-complete)
    ;(global-company-mode)
    :diminish company-mode)

  (use-package company-lsp)
#+end_src

** Ido mode
One of those things you wonder why it's not default in Emacs. It's
basically a completion and search engine, and much more. Several other
packages either support or depend on Ido. I like to pair it with
vertical mode so that candidates appear in a vertical instead of
horizontal list, and flex ido for fuzzy matching.

Finally, ~ido-completing-read+~ replaces stock emacs completion with
ido completion wherever it is possible to do so without breaking
things.

#+begin_src emacs-lisp
(use-package ido
  :config
  (ido-mode 1)
  (setq ido-everywhere t)
  (setq ido-use-faces t)
  (setq ido-use-filename-at-point 'guess)
  (setq ido-use-url-at-point nil)
  (setq ido-enable-flex-matching t)
  ;; restrict to current directory
  (setq ido-auto-merge-work-directories-length -1)

  (defun recentf-ido-find-file ()
    "Find a recent file using ido."
    (interactive)
    (let ((file (ido-completing-read "Choose recent file: " recentf-list nil t)))
      (when file
        (find-file file))))

  (global-set-key (kbd "C-x C-r") 'recentf-ido-find-file))

(use-package ido-vertical-mode
  :config
  (ido-mode 1)
  (ido-vertical-mode 1)
  (setq ido-vertical-define-keys 'C-n-C-p-up-down-left-right))

(use-package flx-ido
  :config
  (flx-ido-mode 1)
  (setq ido-enable-flex-matching t
        ido-use-faces t
        ido-use-filename-at-point t))

(use-package ido-completing-read+
  :config
  (ido-ubiquitous-mode 1))
#+end_src

** Project management
Projectile is the /de facto/ project management package. I rarely
interact with Projectile directly, rather through its integration with
Helm.

It has many options to tweak it to your own needs, and its
documentation website is excellent
[[https://docs.projectile.mx/projectile/configuration.html]]

Here I'm tweaking three settings:

1. Project search path: so that Projectile knows where all my projects
   are located. If you don't set this, simply opening any file of a
   project will add it to the Projectile list of known projects.
2. Modeline function: So it doesn't waste too much space in the
   modeline, I change it to read simply ~P[name of the project]~.
3. Indexing method: There are several indexing methods available. Some
   are native to Emacs, thus portable and don't rely on external
   tools, and some are external to Emacs and rely on external tools
   being present. The main advantage of the external ones are speed. I
   use the "alien" indexing method, which shells out to get a list of
   files. It makes sense because all my projects are kept in VC.

#+begin_src emacs-lisp
(use-package projectile
  :init
  (custom-set-variables '(projectile-keymap-prefix (kbd "C-c p")))
  :config
  (projectile-mode t)
  (setq projectile-project-search-path '("~/workspace/")
        projectile-mode-line-function '(lambda () (format " P[%s]" (projectile-project-name)))
        projectile-indexing-method 'alien
        projectile-completion-system 'helm))
#+end_src

** Helm

*** TODO Documentation

 #+begin_src emacs-lisp
 (use-package helm-flx :pin melpa
   :config (helm-flx-mode +1))

 (use-package helm
   :config
             ;; so helm adapts to your usage
             (helm-adaptive-mode 1)

             ;; window management
             (push '("^\*helm.+\*$" :regexp t) popwin:special-display-config)
             (add-hook 'helm-after-initialize-hook (lambda ()
                                                     (popwin:display-buffer helm-buffer t)
                                                     (popwin-mode -1)))

             ;;  Restore popwin-mode after a Helm session finishes.
             (add-hook 'helm-cleanup-hook (lambda () (popwin-mode 1)))

             (setq helm-idle-delay 0.1)
;             (setq helm-input-idle-delay 0.1)
;             (setq helm-follow-mode-persistent t)
             (setq helm-for-files-preferred-list
                   '(helm-source-buffers-list
                     helm-source-recentf
                     helm-source-bookmarks
                     helm-source-file-cache
                     helm-source-files-in-current-dir
                     helm-source-locate))
             (global-set-key "\C-x\ a" 'helm-for-files)
             (global-set-key (kbd "C-c y") 'helm-show-kill-ring)
             ;; replace M-x with helm's version
             (global-set-key (kbd "M-x") 'helm-M-x)
             ;; replace C-x b with helm's version
             (global-set-key "\C-x\ b" 'helm-mini)
             (global-set-key "\C-x\ \C-r" 'helm-recentf)
             (global-set-key "\C-h\ a" 'helm-apropos)
             (global-set-key (kbd "<f9>") 'helm-bookmarks))

 (use-package helm-projectile
   :config
   (defun contextual-helm-projectile ()
     (if (and (buffer-file-name)
              (projectile-project-p))
         (progn
           (global-unset-key "\C-x\ a")
           (global-set-key "\C-x\ a" 'helm-projectile)
           )
       (progn
         (global-unset-key "\C-x\ a")
         (global-set-key "\C-x\ a" 'helm-for-files)
         )))
   (contextual-helm-projectile)
   (add-hook 'window-configuration-change-hook #'contextual-helm-projectile)
                                         ;(setq projectile-enable-caching t) ;; fix slow invocations of helm-projectile-find-file
   (helm-projectile-on))

 (use-package helm-ag
   :config
   (setq helm-ag-fuzzy-match t)
   (defun helm-ag-projectile-root (&optional ARG)
     "Search from projectile-project-root` which defaults to current directory if no project."
     (interactive)
     (helm-ag (projectile-project-root)))
   (defun helm-do-ag-projectile-root (&optional ARG)
     "Search from projectile-project-root` which defaults to current directory if no project."
     (interactive)
     (helm-do-ag (projectile-project-root))))
 #+end_src

** Spellchecker
#+begin_src emacs-lisp
(use-package flyspell
  :bind ("C-c C-SPC" . ispell-word)
  :diminish flyspell-mode)
#+end_src

** Paredit
Structured editing for Lisp and Lisp-like languages.

#+begin_src emacs-lisp
(use-package paredit
  :config (progn
            (autoload 'enable-paredit-mode "paredit" "Turn on pseudo-structural editing of Lisp code." t)
            (add-hook 'emacs-lisp-mode-hook       #'enable-paredit-mode)
            (add-hook 'eval-expression-minibuffer-setup-hook #'enable-paredit-mode)
            (add-hook 'ielm-mode-hook             #'enable-paredit-mode)
            (add-hook 'lisp-mode-hook             #'enable-paredit-mode)
            (add-hook 'lisp-interaction-mode-hook #'enable-paredit-mode)
            (add-hook 'scheme-mode-hook           #'enable-paredit-mode)
            (add-hook 'clojure-mode-hook          #'enable-paredit-mode)
            (add-hook 'cider-repl-mode-hook       #'enable-paredit-mode)

            (add-hook 'slime-repl-mode-hook (lambda () (paredit-mode +1)))

            (defun override-slime-repl-bindings-with-paredit ()
              (define-key slime-repl-mode-map
                (read-kbd-macro paredit-backward-delete-key) nil))
            (add-hook 'slime-repl-mode-hook
                      'override-slime-repl-bindings-with-paredit t))
  :diminish paredit-mode)
#+end_src

** Eyebrowse
Implements "workspaces" for Emacs. Each workspace can keep different
split settings, and you can switch back and forth between them.

#+begin_src emacs-lisp
(use-package eyebrowse
  :init (progn
          (setq eyebrowse-wrap-around t
                eyebrowse-new-workspace t)
          (eyebrowse-mode 1)
          (eyebrowse-switch-to-window-config-0))
  :diminish eyebrowse-mode)
#+end_src

** Org mode
The gateway drug to Emacs. Org mode is difficult to put in a single
word; it's a note taking application, agenda, markup language,
organizer, documentation engine and more. Org mode organizes your life
in text mode. Most of the options used in this package are documented
as source code comments.

Org mode is able to export to several other formats, and some of them
require additional packages.

#+begin_src emacs-lisp
(use-package ox-hugo)
#+end_src

#+begin_src emacs-lisp
  (use-package org
    :config
    (global-set-key "\C-cl" 'org-store-link)
    (global-set-key "\C-cc" 'org-capture)
    (global-set-key "\C-ca" 'org-agenda)
    (global-set-key "\C-cb" 'org-iswitchb)
    (global-set-key "\C-cr" 'org-list-repair)

    ;; where to put captured notes
    (setq org-default-notes-file "~/Sync/Org/refile.org"

          ;; capture timestamps and notes when TODO state
          ;; changes to DONE
          org-log-done t

          ;; show plain text links by default
          ;; org-descriptive-links nil

          ;; when clocking time for tasks, persist history across
          ;; emacs sessions. Used together with
          ;; (org-clock-persistence-insinuate)
          org-clock-persist 'history

          ;; Default is nil. Source code is indented. This indentation
          ;; applies during export or tangling, and depending on the
          ;; context, may alter leading spaces and tabs. When non-nil,
          ;; source code is aligned with the leftmost column. No lines
          ;; are modified during export or tangling, which is very
          ;; useful for white-space sensitive languages, such as Python.
          ;;
          ;; Local variables can be used to set this to true on specific
          ;; buffers only:
          ;; M-x add-file-local-variable RET org-src-preserve-indentation RET t
          ;; and press C-c on the header arguments
          org-src-preserve-indentation nil

          ;; preserve native color scheme for target source code
          org-src-fontify-natively t

          ;; smart quotes on export
          org-export-with-smart-quotes t
          )

    (add-to-list 'auto-mode-alist '("\\.org$" . org-mode))
    (add-hook 'org-mode-hook (lambda ()
                               (flyspell-mode 1)
                               (electric-pair-mode 1)
                               (delete '("\\.pdf\\'" . default) org-file-apps)
                               (add-to-list 'org-file-apps '("\\.pdf\\'" . "evince %s"))))

    (defun set-exec-path-from-shell-PATH ()
      (let ((path-from-shell
             (replace-regexp-in-string "[[:space:]\n]*$" ""
                                       (shell-command-to-string "$SHELL -l -c 'echo $PATH'"))))
        (setenv "PATH" path-from-shell)
        (setq exec-path (split-string path-from-shell path-separator))))
    (when (equal system-type 'darwin) (set-exec-path-from-shell-PATH))

    ;; see org-clock-persist above
    (org-clock-persistence-insinuate)

    (define-key org-mode-map (kbd "s-u") #'org-goto)
    (define-key org-mode-map (kbd "s-U") #'org-mark-ring-goto)
    (define-key org-mode-map (kbd "s-l") #'org-toggle-link-display)

    (add-hook 'org-mode-hook #'auto-fill-mode)

    ;; exporters
    (require 'ox-md)     ; markdown
    (require 'ox-reveal) ; nice presentations
    (require 'ox-hugo)   ; blogging
    )
#+end_src

*** Roam

#+begin_src emacs-lisp
  (use-package org-roam
    :pin melpa
    :hook (after-init . org-roam-mode)
    :config
    (setq org-roam-completion-system 'ivy
          org-roam-db-location "~/Sync/Org/org-roam.db"
          org-roam-index-file "20201109112056-index.org"
          org-roam-graph-exclude-matcher '("dailies"))
    (require 'org-roam-protocol)
    :custom (org-roam-directory "~/Sync/Org/roam/")
    :bind (:map org-roam-mode-map
                (("C-c n l" . org-roam)
                 ("C-c n f" . org-roam-find-file)
                 ("C-c n g" . org-roam-graph)
                 ("C-c n c" . org-roam-capture))
                :map org-mode-map
                (("C-c n i" . org-roam-insert))
                (("C-c n I" . org-roam-insert-immediate))))
#+end_src

**** Roam Server

     Org Roam already comes with graphing built in, but Roam Server
     displays your note graph in a Web page that you can navigate, see
     previews of your notes by hovering in each node, as well as
     clicking a node to open the corresponding note in Emacs.

#+begin_src emacs-lisp
  (use-package org-roam-server
    :pin melpa
    :config
    (setq org-roam-server-host "127.0.0.1"
          org-roam-server-port 8080
          org-roam-server-authenticate nil
          org-roam-server-export-inline-images t
          org-roam-server-serve-files nil
          org-roam-server-served-file-extensions '("pdf" "mp4" "ogv")
          org-roam-server-network-poll t
          org-roam-server-network-arrows nil
          org-roam-server-network-label-truncate t
          org-roam-server-network-label-truncate-length 60
          org-roam-server-network-label-wrap-length 20))
#+end_src

**** Deft

     Provides full text search capabilities for finding roam notes.

#+begin_src emacs-lisp
  (use-package deft
    :bind ("s-F" . deft)
    :commands (deft)
    :config
    (setq deft-extensions '("org")
          deft-directory "~/Sync/Org/roam"
          deft-recursive t))
#+end_src

*** Literate programming
    A very powerful feature of Org is literate programming. Out of the
    box it is able to execute code blocks from many different
    programming languages. Here I am adding a rest client as well, so
    that you can document an API.

#+begin_src emacs-lisp
  (use-package ob-restclient :pin melpa)

  (org-babel-do-load-languages
     'org-babel-load-languages
     '(
       (emacs-lisp . t)
       (latex . t)
       (js . t)
       (python . t)
       (scheme . t)
       (shell . t)
       (clojure . t)
       (sql . t)
       (restclient . t)
       ))
#+end_src

    Executing code locally can be dangerous of course. However there
    might be times when you want to override the confirmation
    dialog. The following snippet does just that

#+begin_src emacs-lisp
(defun my-org-confirm-babel-evaluate (lang body)
  (not (member lang '("restclient" "emacs-lisp"))))

(setq org-confirm-babel-evaluate 'my-org-confirm-babel-evaluate)
#+end_src

*** Reveal
    So that you can export Org files to Reveal.js presentations

#+begin_src emacs-lisp
(use-package ox-reveal :pin melpa
  :config (progn (setq org-reveal-root "file:///home/cesaro/workspace/reveal.js")))
#+end_src

** Hydra
Hydras are useful bindings grouped together. Once an hydra is invoked,
you are presented with a set of options related to the hydra. It's
useful to group related functionality that is not frequently used, so
you can remember the bindings.

Hydras have various modes, called "colors". The most common are red
and blue. The different colors represent what the hydra does once
invoked. Blue hydras terminate after invocation, making repeated
invocation impossible. Red hydras stick around, so you can invoke
multiple hydras in succession (for example for movement commands)

#+begin_src emacs-lisp
(use-package hydra)
#+end_src

*** Various hydras
    This is a collection of various hydras I've accumulated over the
    years. Most of them are rarely used, but some (like [[Window
    operations]] or [[Eyebrowse]]) are so commonly used that I instinctively reach out
    for them and I don't remember the "native" keybinding.

**** Switch to mode
     Switch to a major mode. A menu is presented with common major
     modes.

 #+begin_src emacs-lisp
 (defhydra hydra-major (:color blue)
   "major mode"
   ("q" sql-mode "SQL")
   ("o" org-mode "org")
   ("t" text-mode "text")
   ("w" web-mode "web")
   ("j" js2-mode "JavaScript")
   ("m" markdown-mode "Markdown"))
 (global-set-key (kbd "C-c m") 'hydra-major/body)
 #+end_src

**** Window operations
     Common window operations. Splitting, resizing, swapping and
     deleting.

 #+begin_src emacs-lisp
 (defhydra hydra-window (:color red :hint nil)
   "
  Split: _v_ert _x_:horz
 Delete: _o_ther ace-_d_elete
 Resize: _h_:splitter left  _j_:splitter down  _k_:splitter up  _l_:splitter right _b_alance windows
   Move: _s_wap
   Misc: _a_ce-window _+_:text increase _-_:text decrease _=_:text adjust
 "
   ("v" split-window-right)
   ("x" split-window-below)
   ("A" hydra-move-splitter-left)
   ("S" hydra-move-splitter-down)
   ("W" hydra-move-splitter-up)
   ("D" hydra-move-splitter-right)
   ("s" ace-swap-window)
   ("d" ace-delete-window)
   ("|" (lambda ()
          (interactive)
          (split-window-right)
          (windmove-right)) "Split right and move")
   ("_" (lambda ()
          (interactive)
          (split-window-below)
          (windmove-down)) "Split below and move")
   ("o" delete-other-windows "Delete other windows" :exit t)
   ("h" shrink-window-horizontally)
   ("j" enlarge-window)
   ("k" shrink-window)
   ("l" enlarge-window-horizontally)
   ("b" balance-windows)
   ("a" ace-window "Ace window" :exit t)
   ("+" text-scale-increase)
   ("-" text-scale-decrease)
   ("=" text-scale-adjust :exit t))
 (global-set-key (kbd "C-c w") 'hydra-window/body)
 #+end_src

**** Moving around
     Collection of move commands. Useful for jumping around large
     files.

 #+begin_src emacs-lisp
 (defhydra hydra-movement (:color blue)
   "movement"
   ("c" avy-goto-char-2 "Go to char")
   ("l" avy-goto-line "Go to line")
   ("L" goto-line "Go to line number")
   ("w" avy-goto-word-1 "Go to word"))
 (global-set-key (kbd "C-c g") 'hydra-movement/body)

 (global-set-key (kbd "C-x w") 'avy-goto-word-1)
 (global-set-key (kbd "C-x g") 'avy-goto-line)
 (global-set-key (kbd "M-.") 'avy-goto-char-2)
 #+end_src

**** Github gists
     Collection of functions to work with gists.

 #+begin_src emacs-lisp
 (defhydra hydra-gist (:color blue)
   "gists"
   ("l" gist-list "List gists")
   ("g" gitst-region-or-buffer "Gist region or buffer")
   ("P" gist-region-or-buffer-private "Gist region or buffer private")
   ("r" gist-region "Gist region")
   ("R" gist-region-private "Private gist")
   ("b" gist-buffer "Gist buffer")
   ("B" gist-buffer-private "Gist buffer private"))
 (global-set-key (kbd "C-c q") 'hydra-gist/body)
 #+end_src

**** Org mode
     Moving around an Org mode file.

 #+begin_src emacs-lisp
 (defhydra hydra-org (:color red :hint nil)
   "
 Capture^       ^Navigation^
 -----------------------------------------------------------
 capture         _j_ next heading
 last capture    _k_ prev heading
                 _h_ next heading (same level)
                 _l_ prev heading (same level)
                 _u_p higher heading
                 _t_oggle
                 _g_o to
 "
   ("j" outline-next-visible-heading)
   ("k" outline-previous-visible-heading)
   ("h" org-forward-heading-same-level)
   ("l" org-backward-heading-same-level)
   ("u" outline-up-heading)
   ("t" org-cycle)
   ("g" org-goto :exit t))
 (global-set-key (kbd "C-c o") 'hydra-org/body)
 #+end_src

**** Utility
     Some miscelaneous functions that don't have a home some place
     else.

 #+begin_src emacs-lisp
 (defhydra hydra-utility (:color blue :hint nil)
   "
 URL^             ^Format^  ^Misc^
 --------------------------------------------------------
 _h_umanify        _j_son    _c_opy filename to clipboard
 _d_ecode region   _x_ml     _s_how filename of buffer
                         _i_nsert filename to buffer
                         _t_oggle letter case"
   ("h" url-humanify)
   ("d" url-decode-region)
   ("j" json-pretty-print)
   ("x" xml-format)
   ("c" copy-file-name-to-clipboard)
   ("s" show-file-name-of-current-buffer)
   ("t" toggle-letter-case :color red)
   ("i" bjm/insert-file-name))
 (global-set-key (kbd "C-c u") 'hydra-utility/body)
 #+end_src

**** Eyebrowse
     Controlling eyebrowse. Switching to workspaces and navigation.

 #+begin_src emacs-lisp
 (defhydra hydra-eyebrowse (:color blue :hint nil)
   "
 Workspace^                     ^Navigation^
 ------------------------------------------------
 Workspace _1_   Workspace _6_   _n_ext workspace
 Workspace _2_   Workspace _7_   _p_rev workspace
 Workspace _3_   Workspace _8_   _l_ast workspace
 Workspace _4_   Workspace _9_   _c_lose workspace
 Workspace _5_   Workspace _0_
 "
   ("1" eyebrowse-switch-to-window-config-0)
   ("2" eyebrowse-switch-to-window-config-2)
   ("3" eyebrowse-switch-to-window-config-3)
   ("4" eyebrowse-switch-to-window-config-4)
   ("5" eyebrowse-switch-to-window-config-5)
   ("6" eyebrowse-switch-to-window-config-6)
   ("7" eyebrowse-switch-to-window-config-7)
   ("8" eyebrowse-switch-to-window-config-8)
   ("9" eyebrowse-switch-to-window-config-9)
   ("0" eyebrowse-switch-to-window-config-0)
   ("n" eyebrowse-next-window-config)
   ("p" eyebrowse-prev-window-config)
   ("l" eyebrowse-last-window-config)
   ("c" eyebrowse-close-window-config))
 (global-set-key (kbd "C-c e") 'hydra-eyebrowse/body)
 #+end_src

**** Flycheck
     Using flycheck. Mainly moving around errors in the current buffer.

 #+begin_src emacs-lisp
 (defhydra hydra-flycheck (:color red :hint nil)
   "
 Navigation^  ^Buffer^
 ------------------
 _j_ Next      _C_lear
 _k_ Prev      _B_uffer
 _h_ First     _D_isable
 _l_ List      _S_etup
 "
   ("j" flycheck-next-error)
   ("k" flycheck-previous-error)
   ("h" flycheck-first-error)
   ("l" flycheck-list-errors :color blue)
   ("C" flycheck-clear)
   ("B" flycheck-buffer)
   ("D" flycheck-disable-checker :color blue)
   ("S" flycheck-verify-setup :color blue))
 (global-set-key (kbd "C-c k") 'hydra-flycheck/body)
 #+end_src

**** Visual bookmarks
     Working with visual bookmarks. Bindings to moving around existing
     bookmarks, creating and toggling.

 #+begin_src emacs-lisp
 (defhydra hydra-bm (:color red :hint nil :timeout 1.0)
   "Bookmarks"
   ("t" bm-toggle "Toggle")
   ("T" bm-toggle "Toggle" :color blue)
   ("j" bm-next "Next")
   ("k" bm-previous "Previous")
   ("l" bm-show "Show local")
   ("A" bm-show-all "Show all")
   ("x" bm-remove-all-current-buffer :color blue)
   ("X" bm-remove-all-all-buffers :color blue))
 (global-set-key (kbd "C-c b") 'hydra-bm/body)
 #+end_src

**** Origami
     Working with the Origami code folding package.

 #+begin_src emacs-lisp
 (defhydra hydra-origami (:color red :hint nil :timeout 1.0)
     "
 Code Folds^       ^Navigation^
 ---------------------------------
 _t_ Toggle       _j_ Move to next
 _T_ Toggle All   _k_ Move to previous
 _u_ undo
 _r_ redo
 _R_ Reset
 "
   ("t" origami-recursively-toggle-node)
   ("T" origami-toggle-all-nodes)
   ("u" origami-undo)
   ("r" origami-redo)
   ("j" origami-next-fold)
   ("k" origami-previous-fold)
   ("R" origami-reset))
 (global-set-key (kbd "C-c f") 'hydra-origami/body)
 #+end_src

**** Timestamp
     Insert various timestamps.

 #+begin_src emacs-lisp
 (defhydra help/hydra/timestamp (:color blue :hint nil)
   "
 Timestamps: (_q_uit)
       Date: _I_SO, _U_S, US With _Y_ear and _D_ashes, US In _W_ords
  Date/Time: _N_o Colons or _w_ith
   Org-Mode: _R_ight Now or _c_hoose
 "
   ("q" nil)

   ("I" help/insert-datestamp)
   ("U" help/insert-datestamp-us)
   ("Y" help/insert-datestamp-us-full-year)
   ("D" help/insert-datestamp-us-full-year-and-dashes)
   ("W" help/insert-datestamp-us-words)

   ("N" help/insert-timestamp-no-colons)
   ("w" help/insert-timestamp)

   ("R" help/org-time-stamp-with-seconds-now)
   ("c" org-time-stamp))
 (global-set-key (kbd "C-c t") #'help/hydra/timestamp/body)
 (defun help/insert-datestamp ()
   "Produces and inserts a partial ISO 8601 format timestamp."
   (interactive)
   (insert (format-time-string "%F")))
 (defun help/insert-datestamp-us ()
   "Produces and inserts a US datestamp."
   (interactive)
   (insert (format-time-string "%m/%d/%y")))
 (defun help/insert-datestamp-us-full-year-and-dashes ()
   "Produces and inserts a US datestamp with full year and dashes."
   (interactive)
   (insert (format-time-string "%m-%d-%Y")))
 (defun help/insert-datestamp-us-full-year ()
   "Produces and inserts a US datestamp with full year."
   (interactive)
   (insert (format-time-string "%m/%d/%Y")))
 (defun help/insert-datestamp-us-words ()
   "Produces and inserts a US datestamp using words."
   (interactive)
   (insert (format-time-string "%A %B %d, %Y")))
 (defun help/insert-timestamp-no-colons ()
   "Inserts a full ISO 8601 format timestamp with colons replaced by hyphens."
   (interactive)
   (insert (help/get-timestamp-no-colons)))
 (defun help/insert-datestamp ()
   "Produces and inserts a partial ISO 8601 format timestamp."
   (interactive)
   (insert (format-time-string "%F")))
 (defun help/get-timestamp-no-colons ()
   "Produces a full ISO 8601 format timestamp with colons replaced by hyphens."
   (interactive)
   (let* ((timestamp (help/get-timestamp))
          (timestamp-no-colons (replace-regexp-in-string ":" "-" timestamp)))
     timestamp-no-colons))
 (defun help/get-timestamp ()
   "Produces a full ISO 8601 format timestamp."
   (interactive)
   (let* ((timestamp-without-timezone (format-time-string "%Y-%m-%dT%T"))
          (timezone-name-in-numeric-form (format-time-string "%z"))
          (timezone-utf-offset
           (concat (substring timezone-name-in-numeric-form 0 3)
                   ":"
                   (substring timezone-name-in-numeric-form 3 5)))
          (timestamp (concat timestamp-without-timezone
                             timezone-utf-offset)))
     timestamp))
 (defun help/insert-timestamp ()
   "Inserts a full ISO 8601 format timestamp."
   (interactive)
   (insert (help/get-timestamp)))
 (defun help/org-time-stamp-with-seconds-now ()
   (interactive)
   (let ((current-prefix-arg '(16)))
     (call-interactively 'org-time-stamp)))
 #+end_src

** Fontawesome
Fontawesome support.

#+begin_src emacs-lisp
(use-package fontawesome)
#+end_src

** Swiper
Swiper is a completion and narrowing package, similar to Ido.

#+begin_src emacs-lisp
(use-package swiper)

(use-package swiper-helm
  :config (progn (global-set-key "\C-s" 'swiper)
                 (global-set-key "\C-r" 'swiper)))
#+end_src

** Fireplace
Add a fireplace to your Emacs session.

#+begin_src emacs-lisp
(use-package fireplace)
#+end_src
** Neotree
Display your filesystem in a tree structure UI.

#+begin_src emacs-lisp
(use-package neotree
  :config
  (global-set-key [f7] 'neotree-toggle)
  (setq neo-theme (if (display-graphic-p) 'icons 'arrow)
        neo-smart-open t
        neo-autorefresh nil
        neo-window-width (if (> (x-display-pixel-width) 5000) 40 35)
        projectile-switch-project-action 'neotree-projectile-action)
  (defun text-scale-once ()
    (interactive)(progn(text-scale-adjust 0)(text-scale-decrease 1)))
  (add-hook 'neo-after-create-hook (lambda (_)(call-interactively 'text-scale-once))))
#+end_src

** Editing
Useful packages for text editing.

*** Expand region
 A very useful package to select regions delimited by various
 means. You can progressively expand and contract the selected region
 using the keyboard.

 #+begin_src emacs-lisp
 (use-package expand-region
   :config
   (global-set-key (kbd "C-=") 'er/expand-region)
   (global-set-key (kbd "C-M-=") 'er/contract-region))
 #+end_src

*** Undo tree
 One of the coolest features of Emacs, one you wonder why not more
 editors have included it as a standard feature. It organizes your
 undo/redo operations as a tree structure, and gives you a visual
 representation of it so you can navigate the tree.

 Never again fear a undo/redo operation makes you lose important edits!

 #+begin_src emacs-lisp
 (use-package undo-tree :pin gnu
   :config
   (global-undo-tree-mode 1)
   (setq undo-tree-history-dir (let ((dir (concat user-emacs-directory
                                                  "undo-tree-history/")))
                                 (make-directory dir :parents)
                                 dir))
   (setq undo-tree-history-directory-alist `(("." . ,undo-tree-history-dir)))
   (defalias 'redo 'undo-tree-redo)
   :diminish undo-tree-mode)
 #+end_src

*** Move text
 Allows you to move lines of text or selected regions up and down.

 #+begin_src emacs-lisp
(use-package move-text
   :config
   :bind (("M-S-<up>" . move-text-up)
          ("M-S-<down>" . move-text-down)))
 #+end_src

*** Anzu
 Search and replace.

 #+begin_src emacs-lisp
 (use-package anzu
   :config
   (global-anzu-mode)
   (set-face-attribute 'anzu-mode-line nil :foreground "white" :weight 'bold)
   :bind ("M-%" . anzu-query-replace)
   :diminish anzu-mode)
 #+end_src

*** Shrink whitepace
 Another of those useful editing packages. This one allows you to
 remove whitespace in front of the cursor.

 #+begin_src emacs-lisp
 (use-package shrink-whitespace
   :bind ("M-SPC" . shrink-whitespace))
 #+end_src
*** Tramp
    Edit files remotely.

#+begin_src emacs-lisp
(use-package tramp
  :config
  ;; Turn off auto-save for tramp files
  (defun tramp-set-auto-save ()
    (auto-save-mode -1))
  (with-eval-after-load 'tramp-cache
    (setq tramp-persistency-file-name (concat user-emacs-directory "tramp")))
  (setq tramp-default-method "ssh"
        tramp-default-user-alist '(("\\`su\\(do\\)?\\'" nil "root"))
        tramp-adb-program "adb"
        tramp-auto-save-directory (concat user-emacs-directory "tramp-autosave")
        tramp-verbose 6
        ;; use the settings in ~/.ssh/config instead of Tramp's
        tramp-use-ssh-controlmaster-options nil
        backup-enable-predicate
        (lambda (name)
          (and (normal-backup-enable-predicate name)
               (not (let ((method (file-remote-p name 'method)))
                      (when (stringp method)
                        (member method '("su" "sudo")))))))))
#+end_src
*** Atomic Chrome
    Edit browser text areas in Emacs.

#+begin_src emacs-lisp
(use-package atomic-chrome
  :pin melpa
  :config
  (setq atomic-chrome-default-major-mode  'text-mode)
  (setq atomic-chrome-buffer-open-style   'frame
        atomic-chrome-buffer-frame-width  100
        atomic-chrome-buffer-frame-height 25)
  ;; (setq atomic-chrome-url-major-mode-alist
  ;;       '(("flotiya\\.local" . js2-mode)
  ;;         ("phabricator" . text-mode)))
  (atomic-chrome-start-server)
  :diminish AtomicChrome)
#+end_src
*** Crux
    Crux is an acronym for a Collection of Ridiculously Useful
    eXtensions for Emacs. It's basically a collection of functions
    accumulated over the years, from Bozhidar Batsov, creator of CIDER
    and Emacs Prelude.

#+begin_src emacs-lisp
(use-package crux
  :config
  (global-set-key [remap move-beginning-of-line] #'crux-move-beginning-of-line)
  (global-set-key [(shift return)] #'crux-smart-open-line)
  (global-set-key (kbd "C-<backspace>") #'crux-kill-line-backwards)
  (global-set-key [remap kill-whole-line] #'crux-kill-whole-line)
  (global-set-key (kbd "C-c n") #'crux-cleanup-buffer-or-region)
  )
#+end_src

*** Buffer flip
    One of the most common operations is switching between open files
    in a buffer. This package allows you to flip between open buffers
    or cancel the flip operation, returning to the original buffer.

#+begin_src emacs-lisp
(use-package buffer-flip
  :bind  (("M-<tab>" . buffer-flip)
  :map buffer-flip-map
          ( "M-<tab>" .   buffer-flip-forward)
          ( "M-<iso-lefttab>" . buffer-flip-backward)
          ( "M-ESC" .     buffer-flip-abort))
  :config
  (setq buffer-flip-skip-patterns
        '("^\\*helm\\b"
          "^\\*swiper\\*$")))
#+end_src

*** Super Save
 Save when Emacs loses focus or when idle. Forget about manual saving.

 #+begin_src emacs-lisp
 (use-package super-save
   :config
   (super-save-mode +1)
   (setq super-save-auto-save-when-idle t
         auto-save-default nil)
   :diminish super-save-mode)
 #+end_src

** Code tools
Packages related to code editing, navigation and related tools.

*** Dumb jump
Jump to definition without generating etags or external tools.

#+begin_src emacs-lisp
(use-package dumb-jump
  :pin melpa
  :ensure t
  :config
  (dumb-jump-mode t)
  (global-set-key (kbd "<f12>") 'dumb-jump-go)
  (setq dumb-jump-selector 'helm))
#+end_src

*** Diffing
 Display diff marks.

 #+begin_src emacs-lisp
 (use-package diff-hl
   :config (progn
             (add-hook 'prog-mode-hook (lambda ()
                                         (diff-hl-mode 1)))))
 #+end_src

*** Rainbow delimiters
 Colorful parens...

 #+begin_src emacs-lisp
 (use-package rainbow-delimiters)
 #+end_src

*** Highlight symbols
 This package implements symbol highlighting, so for example when the
 cursor is in a certain variable name, all instances of that variable
 are highlighted. You can also navigate between all highlights. Very
 useful for programming.

 #+begin_src emacs-lisp
 (use-package highlight-symbol
   :config
   (global-set-key (kbd "<f13>") 'highlight-symbol-at-point)
   (global-set-key (kbd "<f14>") 'highlight-symbol-prev)
   (global-set-key (kbd "<f15>") 'highlight-symbol-next)
   (global-set-key (kbd "<f16>") 'highlight-symbol-query-replace))

 (use-package auto-highlight-symbol :pin melpa
   :config
   (add-hook 'prog-mode-hook (lambda ()
                                         (auto-highlight-symbol-mode t)))
   :diminish auto-highlight-symbol-mode)
 #+end_src

*** Visual bookmarks
 Visible, buffer local bookmarks. Bookmarks are displayed in the fringe
 area, and you can jump between them.

 #+begin_src emacs-lisp
   (use-package bm
     :config (progn
               (define-fringe-bitmap 'bm-marker-left [#xF8
                                                      #xFC
                                                      #xFE
                                                      #x0F
                                                      #x0F
                                                      #xFE
                                                      #xFC
                                                      #xF8])
               (setq bm-highlight-style 'bm-highlight-only-fringe)
               (setq-default bm-buffer-persistence t)
               (add-hook 'after-init-hook 'bm-repository-load)
               (add-hook 'find-file-hooks 'bm-buffer-restore)
               (add-hook 'kill-buffer-hook 'bm-buffer-save)
               (add-hook 'kill-emacs-hook '(lambda nil
                                             (bm-buffer-save-all)
                                             (bm-repository-save)))))
 #+end_src

*** Git history
Navigate your git repository history. Allows you to temporarily revert
a file to a previous version.

#+begin_src emacs-lisp
(use-package git-timemachine)
#+end_src

*** Code folding
    Collapse code regions

#+begin_src emacs-lisp
(use-package origami :pin melpa
  :config (progn
            (add-hook 'prog-mode-hook 'origami-mode)
            (global-set-key (kbd "<f5>") 'origami-recursively-toggle-node)))
#+end_src

*** S3 editing
    Edit files from S3.

#+begin_src emacs-lisp
(use-package s3ed :pin melpa
  :config
  (global-set-key (kbd "C-c s f") 's3ed-find-file)
  (global-set-key (kbd "C-c s s") 's3ed-save-file))
#+end_src

*** REST client
    Add a rest client to your Emacs.

#+begin_src emacs-lisp
(use-package restclient :pin melpa)

(use-package company-restclient :pin melpa
  :config (progn
            (add-hook 'restclient-mode-hook #'company-mode)
            (add-to-list 'company-backends 'company-restclient)))

(use-package restclient-helm :pin melpa)
#+end_src

** Programming modes
These are packages related to adding Emacs support for multiple
programming languages.

*** Web
    Web programming is especially tricky, as you typically need to use
    several other modes in the same file. I don't do a lot of Web
    programming these days, but when I need to, Web mode is good
    enough.

#+begin_src emacs-lisp
(use-package web-mode
  :config (progn
            (add-to-list 'auto-mode-alist '("\\.phtml\\'" . web-mode))
            (add-to-list 'auto-mode-alist '("\\.tpl\\.php\\'" . web-mode))
            (add-to-list 'auto-mode-alist '("\\.jsp\\'" . web-mode))
            (add-to-list 'auto-mode-alist '("\\.as[cp]x\\'" . web-mode))
            (add-to-list 'auto-mode-alist '("\\.erb\\'" . web-mode))
            (add-to-list 'auto-mode-alist '("\\.mustache\\'" . web-mode))
            (add-to-list 'auto-mode-alist '("\\.djhtml\\'" . web-mode))
            (add-to-list 'auto-mode-alist '("\\.html?\\'" . web-mode))

            (setq web-mode-markup-indent-offset 4)
            (setq web-mode-code-indent-offset 4)))
#+end_src

*** JavaScript
    ~js2-mode~ is a JavaScript mode that keeps an AST for syntax
 checking and coloring.

#+begin_src emacs-lisp
 (use-package js2-mode
   :config
   (add-to-list 'auto-mode-alist '("\\.json$" . js2-mode))
   (setq js2-mode-show-parse-errors nil
         js2-mode-show-strict-warnings nil
         js2-basic-offset 2
         js-indent-level 2))
#+end_src

*** Clojure
    Emacs has fantastic support for Clojure with Cider. It provides
    support for interactive programming with Clojure. Over the years
    I've been accumulating tweaks to Cider, but the stock
    configuration is very comprehensible.

    ~subword-mode~ is enabled in ~clojure-mode~ and it treats
    camelCase, snake_case and kebab-case as multiple words. That is,
    the cursor stops in between as in ~some|Word~, ~some|_word~ and
    ~some|-word~.

    Most Cider options tweaks are documented inline. For more
    information refer to the excellent [[https://docs.cider.mx/cider/0.26/index.html][Cider documentation]].

#+begin_src emacs-lisp
(use-package clojure-mode
  :mode (("\\.clj\\'" . clojure-mode)
         ("\\.edn\\'" . clojure-mode))
  :config (require 'flycheck-clj-kondo)
  :init
  (add-hook 'clojure-mode-hook (lambda () (progn
                                            (subword-mode t)
                                            (diminish 'subword-mode))))
  (add-hook 'clojure-mode-hook #'eldoc-mode)
  (diminish 'eldoc-mode))

(use-package cider
  :config
  (defun company-remove-ispell ()
    (when (boundp 'company-backends)
      (make-local-variable 'company-backends)
      ;; remove ispell
      (setq company-backends (delete 'company-dabbrev company-backends))))
  (add-hook 'prog-mode-hook 'company-remove-ispell)

  (add-hook 'cider-repl-mode-hook #'cider-company-enable-fuzzy-completion)
  (add-hook 'cider-mode-hook #'cider-company-enable-fuzzy-completion)
  (add-hook 'cider-mode-hook 'eldoc-mode)
  (add-hook 'cider-repl-mode-hook #'eldoc-mode)

  (setq nrepl-hide-special-buffers t
        cider-repl-use-clojure-font-lock t ; syntax highlighting in REPL
        cider-overlays-use-font-lock t ; syntax highlight evaluation overlays
        cider-repl-toggle-pretty-printing t ; REPL always pretty-prints results
        cider-repl-display-help-banner nil ; don't display start banner
        nrepl-prompt-to-kill-server-buffer-on-quit nil ; don't prompt to kill server buffers on quit
        cider-repl-wrap-history t ; wrap around history when end is reached
        cider-save-file-on-load t ; don't prompt when eval, just save
        cider-font-lock-dynamically '(macro core function var) ; font lock from all namespaces
        org-babel-clojure-backend 'cider ; let org-mode know to use a cider repl to execute snippets
        )

  (define-key cider-repl-mode-map (kbd "C-c M-o") #'cider-repl-clear-buffer))

(use-package helm-cider :pin melpa
  :config (helm-cider-mode 1))
#+end_src
*** Docker
    Support for working with Docker files.

#+begin_src emacs-lisp
(use-package dockerfile-mode
  :diminish Dockerfile)
#+end_src
*** Rust
    Support for working with Rust projects.

#+begin_src emacs-lisp
(use-package rustic :pin melpa
  :config
  (setq lsp-rust-analyzer-server-command (quote ("/home/cesaro/.local/bin/rust-analyzer")))
  (setq lsp-rust-server (quote rust-analyzer)))

#+end_src
*** PHP
#+begin_src emacs-lisp
(use-package php-mode)
#+end_src
*** YAML
    Support for editing YAML files.

#+begin_src emacs-lisp
(use-package yaml-mode)
#+end_src
*** LSP
    A Language Server Protocol client for Emacs. ~lsp-mode~ supports
    many backends, but I only use it for [[Rust][Rust]] (with Rustic) at the
    moment.

#+begin_src emacs-lisp
(use-package lsp-mode
  :commands lsp
  :diminish lsp-mode
  :hook ((rust-mode . lsp)
         (lsp-mode . lsp-enable-which-key-integration))
  :config
  (setq lsp-enable-snippet nil
        lsp-enable-links   nil
        lsp-completion-provider :capf
        lsp-idle-delay 0.500))

(use-package lsp-ui
  :commands lsp-ui-mode)

(use-package helm-lsp
  :config
  (define-key lsp-mode-map [remap xref-find-apropos] #'helm-lsp-workspace-symbol))
#+end_src

* Customization
Customization and custom utility functions. Over the years I've
accumulated many functions I don't actually use. My hope is that by
documenting them I can either set proper bindings or simply remove
them.

** Modes

The following modes are enabled:

- ~save-place-mode~ When you visit a file, point goes to the last
  place where it was when you previously visited the same
  file. Defaults to a file ~places~ stored in your configuration
  directory.
- ~blink-cursor-mode~ Disable cursor blinking. The line containing the
  cursor is visible by highlighting it.
- ~delete-selection-mode~ Insert while having something highlighted
  makes the highlighted text disappear. You know, like a normal
  editor.
- ~column-number-mode~ Display the column number in the modeline.
- ~global-visual-line-mode~ Wrap lines at the word boundary.
- ~auto-revert-mode~ Pick up changes to files on disk automatically
  (ie, after git pull)
- ~which-function-mode~ Displays the name of the function where the
  cursor is located, in the modeline. It also works with Org headers.

#+begin_src emacs-lisp
(setq save-place-file (concat user-emacs-directory "places"))
(save-place-mode 1)

(blink-cursor-mode -1)

(delete-selection-mode t)

(column-number-mode t)

(global-visual-line-mode t)

(global-auto-revert-mode t)

(which-function-mode t)
#+end_src

** Global bindings
The following are bindings to commonly used internal Emacs
functions. Most of the time the name of the function is self
explanatory, but there's also inline comments to explain what the
function does.

#+begin_src emacs-lisp
;; delete next character or whitespace until non-whitespace character
(global-set-key (kbd "C-c d") 'c-hungry-delete-forward)

;; comment and uncomment regions
(global-set-key "\C-c\ -" 'comment-region)
(global-set-key "\C-c\ +" 'uncomment-region)

;; toggle line numbers
(global-set-key [f6] 'display-line-numbers-mode)

;; cleanup whitespace. This is also done on save in prog-mode buffers.
(global-set-key [f2] 'whitespace-cleanup)

;; scroll window up/down by one line, keeping the cursor where it is.
(global-set-key (kbd "M-n") (kbd "C-u 1 C-v"))
(global-set-key (kbd "M-p") (kbd "C-u 1 M-v"))
#+end_src

** Hooks
Defines hooks for many editing modes. For example the configuration
for ~prog-mode~.

Specifically in ~prog-mode~, the following is enabled:
- ~electric-pair-mode~ for automatically inserting matching
  delimiters.
- ~rainbow-mode~ for colorizing color names in the buffer. Works with
  both color names and hex codes.
- ~visual-line-mode~ disabled for preserving long lines.
- ~toggle-truncate-lines~ for truncating long lines and displaying an
  arrow in the fringe instead.
- ~show-paren-mode~ for highlighting the matching paren at point.
- ~whitespace-mode~ for displaying spurious whitespace.
- ~display-fill-column-indicator-column~ for displaying the column
  indicator at the 110 column.
- ~display-fill-column-indicator-mode~ for enabling the fill column
  indicator.

Finally a ~before-save-hook~ is set to cleanup whitespace when the
file is saved.

#+begin_src emacs-lisp
  ;; prog mode setup
  (add-hook 'prog-mode-hook (lambda ()
                              (electric-pair-mode 1)
                              (rainbow-mode 1)
                              (visual-line-mode 0)
                              (toggle-truncate-lines 1)
                              (show-paren-mode t)
                              (whitespace-mode t)
                              (setq display-fill-column-indicator-column 110)
                              (display-fill-column-indicator-mode 1)
                              (add-hook 'before-save-hook #'whitespace-cleanup nil 'make-it-local)
                              (local-set-key (kbd "C-M-;") #'comment-or-uncomment-sexp)))

  ;; but only lisps should have rainbow delimiters
  (add-hook 'lisp-mode-hook 'rainbow-delimiters-mode)
  (add-hook 'clojure-mode-hook 'rainbow-delimiters-mode)

  (add-hook 'text-mode-hook (lambda () (flycheck-mode 0)))

  ;; If all you use is magit anyway, this is not really a loss
  (remove-hook 'find-file-hooks 'vc-find-file-hook)
#+end_src

** Defaults
Here we change some default variables.

#+begin_src emacs-lisp
(setq-default tab-width 2
	      c-basic-offset 4
	      indent-tabs-mode nil
	      c-default-style "linux")

;; encoding
(prefer-coding-system 'utf-8)
(set-language-environment 'utf-8)
(set-default-coding-systems 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-selection-coding-system 'utf-8)

;; highlight incremental search
(defconst search-highlight t)

;; Anwsering y/n is faster than yes/no.
(fset 'yes-or-no-p 'y-or-n-p)

(defun buffer-too-big-p ()
  (or (> (buffer-size) (* 5000 80))
      (> (line-number-at-pos (point-max)) 5000)))

;; Dired setup
;; reuse current buffer by pressing 'a'
(put 'dired-find-alternate-file 'disabled nil)

;; enable some really cool extensions like C-x C-j(dired-jump)
(require 'dired-x)
#+end_src

** Custom functions
These are custom functions, mostly centered around killing and
yanking.

The ~yank-~ set of functions are meant to automatically indent yanked
text if in programming modes.

The ~xah-~ functions are to kill or copy lines. If no mark is set,
then they work on the line where the cursor is located.

#+begin_src emacs-lisp
(require 'dash)

(defvar yank-indent-modes '(prog-mode)
  "Modes in which to indent regions that are yanked (or yank-popped)")

(defvar yank-advised-indent-threshold 1000
  "Threshold (# chars) over which indentation does not automatically occur.")

(defun yank-advised-indent-function (beg end)
  "Do indentation, as long as the region isn't too large."
  (if (<= (- end beg) yank-advised-indent-threshold)
      (indent-region beg end nil)))

(defadvice yank (after yank-indent activate)
  "If current mode is one of 'yank-indent-modes, indent yanked text (with prefix arg don't indent)."
  (if (and (not (ad-get-arg 0))
           (member major-mode yank-indent-modes))
      (let ((transient-mark-mode nil))
        (yank-advised-indent-function (region-beginning) (region-end)))))

(defadvice yank-pop (after yank-pop-indent activate)
  "If current mode is one of 'yank-indent-modes, indent yanked text (with prefix arg don't indent)."
  (if (and (not (ad-get-arg 0))
           (member major-mode yank-indent-modes))
      (let ((transient-mark-mode nil))
        (yank-advised-indent-function (region-beginning) (region-end)))))

(defun yank-unindented ()
  (interactive)
  (yank 1))

(defun xah-cut-line-or-region ()
  "Cut current line, or text selection.
When `universal-argument' is called first, cut whole buffer (respects `narrow-to-region').

URL `http://ergoemacs.org/emacs/emacs_copy_cut_current_line.html'
Version 2015-05-06"
  (interactive)
  (let (Î¾p1 Î¾p2)
    (if current-prefix-arg
        (progn (setq Î¾p1 (point-min))
               (setq Î¾p2 (point-max)))
      (progn (if (use-region-p)
                 (progn (setq Î¾p1 (region-beginning))
                        (setq Î¾p2 (region-end)))
               (progn (setq Î¾p1 (line-beginning-position))
                      (setq Î¾p2 (line-beginning-position 2))))))
    (kill-region Î¾p1 Î¾p2)))
(global-set-key (kbd "C-w") 'xah-cut-line-or-region)

(defun xah-copy-line-or-region ()
  "Copy current line, or text selection.
When `universal-argument' is called first, copy whole buffer (respects `narrow-to-region').

URL `http://ergoemacs.org/emacs/emacs_copy_cut_current_line.html'
Version 2015-05-06"
  (interactive)
  (let (Î¾p1 Î¾p2)
    (if current-prefix-arg
        (progn (setq Î¾p1 (point-min))
               (setq Î¾p2 (point-max)))
      (progn (if (use-region-p)
                 (progn (setq Î¾p1 (region-beginning))
                        (setq Î¾p2 (region-end)))
               (progn (setq Î¾p1 (line-beginning-position))
                      (setq Î¾p2 (line-end-position))))))
    (kill-ring-save Î¾p1 Î¾p2)
    (if current-prefix-arg
        (message "buffer text copied")
      (message "text copied"))))
(global-set-key (kbd "M-w") 'xah-copy-line-or-region)

(defun modi/switch-to-scratch-and-back (arg)
  "Toggle between *scratch-MODE* buffer and the current buffer.
If a scratch buffer does not exist, create it with the major mode set to that
of the buffer from where this function is called.

        COMMAND -> Open/switch to a scratch buffer in the current buffer's major mode
    C-0 COMMAND -> Open/switch to a scratch buffer in `fundamental-mode'
    C-u COMMAND -> Open/switch to a scratch buffer in `org-mode'
C-u C-u COMMAND -> Open/switch to a scratch buffer in `emacs-elisp-mode'"
  (interactive "p")
  (if (and (= arg 1) ; no prefix
           (string-match-p "\\*scratch" (buffer-name)))
      (switch-to-buffer (other-buffer))
    (let ((mode-str (cl-case arg
                      (0  "fundamental-mode") ; C-0
                      (4  "org-mode") ; C-u
                      (16 "emacs-lisp-mode") ; C-u C-u
                      (t  (format "%s" major-mode))))) ; no prefix
      (switch-to-buffer (get-buffer-create
                         (concat "*scratch-" mode-str "*")))
      (funcall (intern mode-str)))))
(global-set-key (kbd "<f8>") 'modi/switch-to-scratch-and-back)

;;; Stefan Monnier <foo at acm.org>. It is the opposite of fill-paragraph
(defun unfill-paragraph (&optional region)
  "Takes a multi-line paragraph and makes it into a single line of text."
  (interactive (progn (barf-if-buffer-read-only) '(t)))
  (let ((fill-column (point-max))
        ;; This would override `fill-column' if it's an integer.
        (emacs-lisp-docstring-fill-column t))
    (fill-paragraph nil region)))
(define-key global-map "\M-Q" 'unfill-paragraph)

(defun joaot/delete-process-at-point ()
  (interactive)
  (let ((process (get-text-property (point) 'tabulated-list-id)))
    (cond ((and process
                (processp process))
           (delete-process process)
           (revert-buffer))
          (t
           (error "no process at point!")))))

(define-key process-menu-mode-map (kbd "C-k") 'joaot/delete-process-at-point)
#+end_src

* Utility
These functions have a dedicated [[Hydra]].

#+begin_src emacs-lisp
;; Prefix all commands with Fn-u
(define-prefix-command 'utility-map)
(global-set-key (kbd "H-z") 'utility-map)
(defun url-humanify ()
  "Take the URL at point and make it human readable."
  (interactive)
  (let* ((area (bounds-of-thing-at-point 'url))
         (num-params  (count-occurances-in-region "&" (car area) (cdr area)))
         (i 0))
    (beginning-of-thing 'url)
    (when (search-forward "?" (cdr area) t nil)
      (insert "\n  ")
      (while (< i num-params)
        (search-forward "&" nil t nil)
        (insert "\n  ")
        (save-excursion
          (previous-line)
          (beginning-of-line)
          (let ((start (search-forward "="))
                (end (search-forward "&")))
            (url-decode-region start end)))
        (setq i (+ i 1))))))
(define-key utility-map (kbd "H-u") 'url-humanify)

(defun url-decode-region (start end)
  "Replace a region with the same contents, only URL decoded."
  (interactive "r")
  (let ((text (url-unhex-string (buffer-substring start end))))
    (delete-region start end)
    (insert text)))
(define-key utility-map (kbd "H-d") 'url-decode-region)

;; format json
(define-key utility-map (kbd "H-j") 'json-pretty-print)

(defun xml-format (begin end)
  "Pretty format XML markup in region. You need to have 'nxml-mode'
http://www.emacswiki.org/cgi-bin/wiki/NxmlMode installed to do
this.  The function inserts linebreaks to separate tags that have
nothing but whitespace between them.  It then indents the markup
by using nxml's indentation rules."
  (interactive "r")
  (save-excursion
      (nxml-mode)
      (goto-char begin)
      (while (search-forward-regexp "\>[ \\t]*\<" nil t)
        (backward-char) (insert "\n"))
      (indent-region begin end))
    (message "Ah, much better!"))
(define-key utility-map (kbd "H-x") 'xml-format)

; copy filename to clipboard
(defun copy-file-name-to-clipboard ()
  "Copy the current buffer file name to the clipboard."
  (interactive)
  (let ((filename (if (equal major-mode 'dired-mode)
                      default-directory
                    (buffer-file-name))))
    (when filename
      (kill-new filename)
      (message "Copied buffer file name '%s' to the clipboard." filename))))
(define-key utility-map (kbd "H-c") 'copy-file-name-to-clipboard)

; show filename of current buffer
(defun show-file-name-of-current-buffer ()
  "Print the current buffer file name"
  (interactive)
  (let ((filename (if (equal major-mode 'dired-mode)
                      default-directory
                    (buffer-file-name))))
    (when filename
      (message filename))))
(define-key utility-map (kbd "H-s") 'show-file-name-of-current-buffer)

(defun bjm/insert-file-name (filename &optional args)
  "Insert name of file FILENAME into buffer after point.

 Prefixed with \\[universal-argument], expand the file name to
 its fully canocalized path. See `expand-file-name'.

 Prefixed with \\[negative-argument], use relative path to file
 name from current directory, `default-directory'. See
 `file-relative-name'.

 The default with no prefix is to insert the file name exactly as
 it appears in the minibuffer prompt."
  ;; Based on insert-file in Emacs -- ashawley 20080926
  (interactive "*fInsert file name: \nP")
  (cond ((eq '- args)
         (insert (expand-file-name filename)))
        ((not (null args))
         (insert (filename)))
        (t
         (insert (file-relative-name filename)))))

; replacement for all the other M-u M-l nonsense
(defun toggle-letter-case ()
  "Toggle the letter case of current word or text selection.
Toggles between: âall lowerâ, âInit Capsâ, âALL CAPSâ."
  (interactive)
  (let (p1 p2 (deactivate-mark nil) (case-fold-search nil))
    (if (region-active-p)
        (setq p1 (region-beginning) p2 (region-end))
      (let ((bds (bounds-of-thing-at-point 'word) ) )
        (setq p1 (car bds) p2 (cdr bds)) ) )

    (when (not (eq last-command this-command))
      (save-excursion
        (goto-char p1)
        (cond
         ((looking-at "[[:lower:]][[:lower:]]") (put this-command 'state "all lower"))
         ((looking-at "[[:upper:]][[:upper:]]") (put this-command 'state "all caps") )
         ((looking-at "[[:upper:]][[:lower:]]") (put this-command 'state "init caps") )
         ((looking-at "[[:lower:]]") (put this-command 'state "all lower"))
         ((looking-at "[[:upper:]]") (put this-command 'state "all caps") )
         (t (put this-command 'state "all lower") ) ) ) )

    (cond
     ((string= "all lower" (get this-command 'state))
      (upcase-initials-region p1 p2) (put this-command 'state "init caps"))
     ((string= "init caps" (get this-command 'state))
      (upcase-region p1 p2) (put this-command 'state "all caps"))
     ((string= "all caps" (get this-command 'state))
      (downcase-region p1 p2) (put this-command 'state "all lower")) )
    ) )
(global-set-key (kbd "M-c") 'toggle-letter-case)

(defun my/org-days-between (start end)
  "Number of days between START and END (exclusive).
This includes START but not END."
  (- (calendar-absolute-from-gregorian (org-date-to-gregorian end))
     (calendar-absolute-from-gregorian (org-date-to-gregorian start))))
#+end_src

* Keymaps
I used these keymaps for easy typing of Spanish accented vowels. I
don't use it nearly as much when I switched to Linux and using a
programmable keyboard, but it's still useful when typing in a laptop
keyboard with no easy access to a compose key.

#+begin_src emacs-lisp
(global-set-key (kbd "H-a") (lambda () (interactive) (insert "Ã¡")))
(global-set-key (kbd "H-e") (lambda () (interactive) (insert "Ã©")))
(global-set-key (kbd "H-i") (lambda () (interactive) (insert "Ã­")))
(global-set-key (kbd "H-o") (lambda () (interactive) (insert "Ã³")))
(global-set-key (kbd "H-u") (lambda () (interactive) (insert "Ãº")))
(global-set-key (kbd "H-n") (lambda () (interactive) (insert "Ã±")))
(global-set-key (kbd "H-?") (lambda () (interactive) (insert "Â¿")))
(global-set-key (kbd "H-!") (lambda () (interactive) (insert "Â¡")))
#+end_src
